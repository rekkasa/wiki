<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="This is a test">

<title>wiki - Knowledge graphs book (Hogen et al)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#types-of-graphs-models" id="toc-types-of-graphs-models" class="nav-link active" data-scroll-target="#types-of-graphs-models">Types of graphs (models)</a></li>
  <li><a href="#graph-patterns" id="toc-graph-patterns" class="nav-link" data-scroll-target="#graph-patterns">Graph patterns</a></li>
  <li><a href="#schema" id="toc-schema" class="nav-link" data-scroll-target="#schema">Schema</a></li>
  <li><a href="#identification" id="toc-identification" class="nav-link" data-scroll-target="#identification">Identification</a></li>
  <li><a href="#ontologies" id="toc-ontologies" class="nav-link" data-scroll-target="#ontologies">Ontologies</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Knowledge graphs book (Hogen et al)</h1>
</div>

<div>
  <div class="description">
    This is a test
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="types-of-graphs-models" class="level2">
<h2 class="anchored" data-anchor-id="types-of-graphs-models">Types of graphs (models)</h2>
<ul>
<li><strong>Directed edge-labelled graphs</strong>: A directed edge-labelled graph (also known as a multi-relational graph) is defined as a set of nodes and a set of directed labelled edges between those nodes. In the case of knowledge graphs, nodes are used to represent entities and edges are used to represent (binary) relations between those entities</li>
</ul>
<div class="equation-box">
<p><strong><em>Definition</em></strong></p>
<p>Let <span class="math inline">\(\textbf{Con}\)</span> be a countably infinite set of constants. A directed edge-labelled graph is a tuple <span class="math inline">\(G=(V,E,L)\)</span>, where <span class="math inline">\(V\subseteq\textbf{Con}\)</span> is a set of nodes, <span class="math inline">\(L\subseteq\textbf{Con}\)</span>, and <span class="math inline">\(E\subseteq V\times L\times V\)</span> is a set of edges.</p>
</div>
<ul>
<li><strong>Heterogeneous graphs</strong>: A heterogeneous graph (or heterogeneous information network) is a graph where each node and edge is assigned one type.</li>
</ul>
<div class="equation-box">
<p><strong><em>Definition</em></strong></p>
<p>A heterogeneous graph is a tuple <span class="math inline">\(G=(V,E,L,l)\)</span>, where <span class="math inline">\(V\subseteq\textbf{Con}\)</span> is a set of nodes, <span class="math inline">\(L\subseteq\textbf{Con}\)</span> is a set of edge/node labels, <span class="math inline">\(E\subseteq V\times L\times V\)</span> is a set of edges, and <span class="math inline">\(l:V\mapsto L\)</span> maps each node to a label.</p>
</div>
<ul>
<li><strong>Property graphs</strong>: A property graph allows a set of property–value pairs and a label to be associated with both nodes and edges.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../images/knowledge_graphs/property_graph.png" class="img-fluid figure-img"></p>
<figcaption>Property graph.</figcaption>
</figure>
</div>
<div class="equation-box">
<p><strong><em>Definition</em></strong></p>
<p>A property graph is a tuple <span class="math inline">\(G=(V,E,L,P,U,e,l,p)\)</span>, where <span class="math inline">\(V\subseteq\textbf{Con}\)</span> is a set of node ids, <span class="math inline">\(E\subseteq\textbf{Con}\)</span> is a set of edge ids, <span class="math inline">\(L\subseteq\textbf{Con}\)</span> is a set of labels, <span class="math inline">\(P\subseteq\textbf{Con}\)</span> is a set of properties, <span class="math inline">\(U\subseteq\textbf{Con}\)</span> is a set of values, <span class="math inline">\(e:E\mapsto V\times V\)</span> maps an edge id to a pair of node ids, <span class="math inline">\(l:V\cup E\mapsto 2^L\)</span> maps an edge or a node id to a set of labels, and <span class="math inline">\(p:V\cup E\mapsto 2^{P\times U}\)</span> maps an edge or a node id to a set of property-value pairs.</p>
</div>
</section>
<section id="graph-patterns" class="level2">
<h2 class="anchored" data-anchor-id="graph-patterns">Graph patterns</h2>
<div class="equation-box">
<p><strong><em>Definition</em></strong></p>
<p>We define variables <span class="math inline">\(\textbf{Var}\)</span> ranging over (but disjoint from <span class="math inline">\(\textbf{Con}\cap\textbf{Var}=\varnothing\)</span>) the set of constants. We define terms as <span class="math inline">\(\textbf{Term} = \textbf{Con}\cup\textbf{Var}\)</span>. Then, a basic directed edge-labelled graph pattern is a tuple <span class="math inline">\(Q=(V,E,L)\)</span>, where <span class="math inline">\(V\subseteq\textbf{Term}\)</span> is a set of node terms, <span class="math inline">\(L\subseteq\textbf{Term}\)</span> is a set of edge terms, and <span class="math inline">\(E\subseteq V\times L\times V\)</span> is a set of edges.</p>
</div>
<p>To evaluate a graph pattern we need to, first, define a mapping <span class="math inline">\(\mu:\textbf{Var}\mapsto\textbf{Con}\)</span> from variables to constants, whose domain is denoted by <span class="math inline">\(dom(\mu)\)</span>. Let <span class="math inline">\(\textbf{Var}(Q)\)</span> denote all the variables appearing in <span class="math inline">\(Q\)</span>.</p>
<div class="equation-box">
<p><strong><em>Definition</em></strong></p>
<p>Let <span class="math inline">\(Q\)</span> be a basic graph pattern and <span class="math inline">\(G\)</span> be a data graph, in the same model. Then, we define the evaluation of the basic graph pattern <span class="math inline">\(Q\)</span> over data graph <span class="math inline">\(G\)</span>, denoted <span class="math inline">\(Q(G)\)</span>, to be the set of mappings <span class="math inline">\(Q(G)=\{\mu|\mu(Q)\subseteq G \text{ and } dom(\mu)=\textbf{Var}(Q)\}\)</span></p>
</div>
<ul>
<li>Unary operators include projection:
<ul>
<li>(𝜋) to output a subset of columns</li>
<li>(𝜎) selection to output a subset of rows matching a given condition</li>
<li>(𝜌) renaming of columns</li>
</ul></li>
<li>Binary operators include:
<ul>
<li>union (∪) to merge the rows of two tables into one table</li>
<li>difference (−) to remove the rows from the first table present in the second table</li>
<li>and joins (Z) to extend the rows of one table with rows from the other table that satisfy a join condition.</li>
</ul></li>
<li>Selection and join conditions typically include:
<ul>
<li>equalities (=)</li>
<li>inequalities (≤)</li>
<li>negation (¬)</li>
<li>disjunction (∨)</li>
<li>etc…</li>
</ul></li>
<li>From these operators, we can further define other (syntactic) operators:
<ul>
<li>intersection (∩) outputs rows in both tables</li>
<li>anti-join (▷, aka not exists) outputs rows from the first table for which there are no join-compatible rows in the second table</li>
<li>left-join (⟕, aka optional) performs a join but keeping rows from the first table without a compatible row in the second table</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../images/knowledge_graphs/complex_graph_pattern.png" class="img-fluid figure-img" style="width:75.0%"></p>
<figcaption>Complex graph patterns (Definition 2.8)</figcaption>
</figure>
</div>
</section>
<section id="schema" class="level2">
<h2 class="anchored" data-anchor-id="schema">Schema</h2>
<ul>
<li>Semantic schema:
<ul>
<li>Defines the meaning of high level terms (aka <em>vocabulary</em> or <em>terminology</em>), facilitating reasoning over graphs.</li>
<li>Groupings of nodes into <em>Classes</em>.</li>
<li>Semantic edge labels are also called <em>properties</em>. Edge labels can also form hierarchies of <em>properties</em> and <em>sub-properties</em>.</li>
<li>A <em>domain of properties</em> indicates the class(es) of entities for nodes <strong>from</strong> which edges with these properties extend.</li>
<li>A <em>range of properties</em> indicates the classes of entities for nodes <strong>to</strong> which edges with these properties extend.</li>
</ul></li>
</ul>
</section>
<section id="identification" class="level2">
<h2 class="anchored" data-anchor-id="identification">Identification</h2>
<ul>
<li><p>Persistent identifiers (PIDs) uniquely identify an entity. Prominent examples of PID schemes include Digital Object Identifiers (DOIs) for papers, ORCID IDs for authors, International Standard Book Numbers (ISBNs) for books, Alpha-2 codes for counties.</p></li>
<li><p>Rather than adopt the Uniform Resource Locators (URLs) used to identify the location of information resources such as webpages, <em>RDF 1.1</em> proposes to use Internationalised Resource Identifiers (IRIs) to identify non-information resources. For example, in the RDF representation of the Wikidata while the URL https://www.wikidata.org/<strong><em>wiki</em></strong>/Q2887 refers to a webpage that can be loaded in a browser providing human-readable meta-data about Santiago, the IRI http://www.wikidata.org/<strong><em>entity</em></strong>/Q2887 refers to the city itself. Distinguishing the identifiers for both resources (the webpage and the city itself) avoids naming clashes.</p></li>
<li><p>External identity links. Problem when different sources refer to the same entity. Mitigate by:</p>
<ul>
<li>Associate with uniquely-identifying information in the graph</li>
<li>Use identity links stating that local entities are the same as external ones (<em>owl:sameAs</em>)</li>
</ul></li>
<li><p>Datatypes are values such as dates, numbers etc that does not make sense to assign an IRI. RDF utilizes XML Schema Datatypes (XSD) where a datatype node is given a pair <em>(l,d)</em>, where <em>l</em> is a lexical string and <em>d</em> is an IRI denoting the datatype, e.g.&nbsp;<em>xsd:dateTime</em>. <strong>:Important:</strong> Datatype nodes in RDF are not allowed to have outgoing edges.</p></li>
<li><p>Lexicalization: Often, node identifiers are not designed to be human-interpretable. It is common to add edges that provide human-interpretable labels for nodes, e.g.&nbsp;<em>[wd:Q2887] –(rdfs:label)–&gt; [“Santiago”]</em>.</p></li>
<li><p>Existential nodes: In the case of incomplete information –&gt; define empty nodes. Authors call for minimized usage of existential nodes.</p></li>
</ul>
</section>
<section id="ontologies" class="level2">
<h2 class="anchored" data-anchor-id="ontologies">Ontologies</h2>
<ul>
<li><p><strong>Definition</strong>: An ontology is a concrete, formal representation of what terms mean within the scope they are used. It leads to consistent use of terms and consistent modeling in a KG. If an ontology is adopted by multiple KGs, it leads to increased interoperability among them. One of the most popular ontology languages is the Web Ontology Language (OWL), recommended by W3C and compatible with RDF graphs.</p></li>
<li><p><strong>Interpretation</strong>: Abstractly, interpretation can be thought of comprising of two elements: a domain graph and a mapping from the terms (nodes and edges) of the data graph to those of the domain graph,</p></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>